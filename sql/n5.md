# Ejercicios SQL - Funciones Escalares

Este conjunto de ejercicios está diseñado para practicar funciones escalares usando las tablas `products`, `customers` y `payments`. Todos los ejercicios se pueden resolver con los conocimientos adquiridos en la unidad.

---

## Estructura de las tablas

### Tabla `products`

| Columna | Descripción |
|---------|-------------|
| `productCode` | Código del producto |
| `productName` | Nombre del producto |
| `quantityInStock` | Cantidad en stock |
| `buyPrice` | Precio de compra |
| `MSRP` | Precio de venta sugerido |

### Tabla `customers`

| Columna | Descripción |
|---------|-------------|
| `customerNumber` | Identificador único del cliente |
| `customerName` | Nombre de la empresa del cliente |
| `contactLastName` | Apellido del contacto principal |
| `contactFirstName` | Nombre del contacto principal |
| `city` | Ciudad |
| `country` | País |
| `creditLimit` | Límite de crédito |

### Tabla `payments`

| Columna | Descripción |
|---------|-------------|
| `customerNumber` | Identificador del cliente |
| `checkNumber` | Número de cheque |
| `paymentDate` | Fecha del pago |
| `amount` | Monto del pago |

---

## Ejercicio 1: Redondear hacia arriba con CEIL

**Enunciado:**
Escribe una consulta que muestre el nombre del producto y el precio de compra redondeado siempre hacia arriba (al siguiente entero).

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT productName, CEIL(buyPrice) AS "Precio Redondeado Arriba" FROM products;
```

**Explicación:**
La función `CEIL()` siempre redondea hacia arriba. Si `buyPrice` es 15.1, el resultado será 16. Si es 15.9, también será 16. Es útil cuando quieres asegurar que no pasarás por debajo de cierto precio.

</details>

---

## Ejercicio 2: Redondear hacia abajo con FLOOR

**Enunciado:**
Escribe una consulta que muestre el nombre del producto y el precio de compra redondeado siempre hacia abajo (al entero inferior).

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT productName, FLOOR(buyPrice) AS "Precio Redondeado Abajo" FROM products;
```

**Explicación:**
La función `FLOOR()` siempre redondea hacia abajo. Si `buyPrice` es 15.9, el resultado será 15. Si es 15.1, también será 15. Es útil para límites mínimos garantizados.

</details>

---

## Ejercicio 3: Diferencia entre MSRP y buyPrice

**Enunciado:**
Escribe una consulta que muestre el nombre del producto, el MSRP (precio sugerido) y el margen de ganancia (diferencia entre MSRP y buyPrice). No uses alias, solo las columnas.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT productName, MSRP, MSRP - buyPrice FROM products;
```

**Explicación:**
Podemos restar dos columnas para calcular la diferencia. `MSRP - buyPrice` nos da el margen de ganancia potencial de cada producto. Los valores positivos indican ganancia, los negativos (si los hay) indicarían pérdida.

</details>

---

## Ejercicio 4: Valor absoluto de desviaciones

**Enunciado:**
Escribe una consulta que muestre el nombre del producto y el valor absoluto de la diferencia entre MSRP y buyPrice, con alias "Margen Absoluto".

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT productName, ABS(MSRP - buyPrice) AS "Margen Absoluto" FROM products;
```

**Explicación:**
La función `ABS()` devuelve el valor absoluto (sin signo negativo). Si la diferencia es -10, `ABS()` devolverá 10. Esto es útil cuando solo te importa la magnitud de la diferencia, no su dirección.

</details>

---

## Ejercicio 5: MOD para obtener residuo

**Enunciado:**
Escribe una consulta que muestre el nombre del producto y el número de stock (`quantityInStock`), y calcula cuántos productos quedan si los empaquetas en grupos de 10 (el residuo cuando divides entre 10).

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT productName, quantityInStock, MOD(quantityInStock, 10) AS "Stock Residuo" FROM products;
```

**Explicación:**
La función `MOD(dividendo, divisor)` devuelve el residuo de una división. `MOD(quantityInStock, 10)` te dice cuántas unidades quedan después de empaquetar en grupos de 10. Por ejemplo, si `quantityInStock` es 47, el resultado es 7 (47 = 4×10 + 7).

</details>

---

## Ejercicio 6: Convertir texto a mayúsculas

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente en mayúsculas y el país. Usa alias "Nombre Mayúsculas" para el nombre.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT UPPER(customerName) AS "Nombre Mayúsculas", country FROM customers;
```

**Explicación:**
La función `UPPER()` convierte todo el texto a mayúsculas. "Blue Whale Records" se convierte en "BLUE WHALE RECORDS". Es útil para estandarizar formato de texto o para búsquedas insensibles a mayúsculas.

</details>

---

## Ejercicio 7: Convertir texto a minúsculas

**Enunciado:**
Escribe una consulta que muestre el apellido del contacto (`contactLastName`) en minúsculas y el nombre del cliente (`customerName`). Usa alias "Apellido Minúsculas".

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT LOWER(contactLastName) AS "Apellido Minúsculas", customerName FROM customers;
```

**Explicación:**
La función `LOWER()` convierte todo el texto a minúsculas. "SMITH" se convierte en "smith". Es útil para normalizar datos o hacer comparaciones insensibles a mayúsculas.

</details>

---

## Ejercicio 8: Eliminar espacios en blanco con TRIM

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente con los espacios en blanco al inicio y final eliminados. Usa alias "Nombre Limpio".

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT TRIM(customerName) AS "Nombre Limpio" FROM customers;
```

**Explicación:**
La función `TRIM()` elimina espacios en blanco al inicio y final del texto. Si `customerName` es "  Blue Whale Records  ", el resultado será "Blue Whale Records" sin espacios extras. Es útil para limpiar datos con espacios accidentales.

</details>

---

## Ejercicio 9: Extraer parte del texto con SUBSTRING

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente y extraiga los primeros 10 caracteres del nombre. Usa alias "Primeros 10".

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT customerName, SUBSTRING(customerName, 1, 10) AS "Primeros 10" FROM customers;
```

**Explicación:**
La función `SUBSTRING(texto, inicio, longitud)` extrae una parte de un texto. `SUBSTRING(customerName, 1, 10)` extrae 10 caracteres comenzando desde la posición 1. Si `customerName` es "Blue Whale Records", el resultado es "Blue Whale".

</details>

---

## Ejercicio 10: SUBSTRING desde posición específica

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente y extraiga 5 caracteres comenzando desde la posición 6. Usa alias "Posición 6".

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT customerName, SUBSTRING(customerName, 6, 5) AS "Posición 6" FROM customers;
```

**Explicación:**
`SUBSTRING(customerName, 6, 5)` extrae 5 caracteres comenzando desde la posición 6. En "Blue Whale Records", la posición 6 es el espacio después de "Blue", así que obtendría "Whale".

</details>

---

## Ejercicio 11: Controlar nulos con COALESCE

**Enunciado:**
Escribe una consulta que muestre el número de cheque de los pagos, pero si es nulo, muestre "Sin cheque" en su lugar.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT COALESCE(checkNumber, "Sin cheque") AS "Número de Cheque" FROM payments;
```

**Explicación:**
La función `COALESCE()` devuelve el primer valor que no sea nulo. Si `checkNumber` tiene un valor, lo muestra. Si es nulo, muestra "Sin cheque". Es muy útil para manejar datos faltantes.

</details>

---

## Ejercicio 12: COALESCE con múltiples valores

**Enunciado:**
Escribe una consulta que para los clientes, muestre una descripción de contacto que use: primero el nombre del contacto (`contactFirstName`), si no existe usa el apellido (`contactLastName`), y si tampoco existe usa "Contacto desconocido".

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT customerName, COALESCE(contactFirstName, contactLastName, "Contacto desconocido") AS "Contacto" FROM customers;
```

**Explicación:**
`COALESCE()` puede tomar múltiples parámetros. Devuelve el primer valor que no sea nulo. Si `contactFirstName` es nulo, intenta con `contactLastName`. Si ambos son nulos, devuelve "Contacto desconocido".

</details>

---

## Ejercicio 13: Combinación de funciones escalares

**Enunciado:**
Escribe una consulta que muestre:
- El nombre del cliente en mayúsculas
- El precio de compra redondeado a 2 decimales
- El margen de ganancia (MSRP - buyPrice) redondeado a 2 decimales

Para los primeros 5 productos.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  UPPER(productName) AS "Producto Mayúsculas",
  ROUND(buyPrice, 2) AS "Precio Compra",
  ROUND(MSRP - buyPrice, 2) AS "Margen Ganancia"
FROM products 
LIMIT 5;
```

**Explicación:**
Las funciones escalares se pueden anidar (poner una dentro de otra). `ROUND(MSRP - buyPrice, 2)` primero calcula la diferencia y luego redondea el resultado a 2 decimales. Las funciones escalares transforman datos a nivel de cada fila.

</details>

---

## Ejercicio 14: ROUND con agregado

**Enunciado:**
Escribe una consulta que calcule el promedio del precio de compra y redondéalo a 2 decimales.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT ROUND(AVG(buyPrice), 2) AS "Promedio Precio" FROM products;
```

**Explicación:**
Las funciones escalares pueden combinarse con funciones de agregado. Primero `AVG()` calcula el promedio de todos los precios de compra, luego `ROUND()` redondea el resultado. El orden es importante: el agregado se calcula primero, luego se aplica la función escalar.

</details>

---

## Ejercicio 15: UPPER con WHERE

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente en mayúsculas para clientes que tienen un crédito mayor a 100000.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT UPPER(customerName) AS "Cliente" FROM customers WHERE creditLimit > 100000;
```

**Explicación:**
Las funciones escalares funcionan bien con filtros. El `WHERE` se aplica primero (filtrando clientes), y luego `UPPER()` transforma el texto a mayúsculas para los resultados filtrados.

</details>

---

## Ejercicio 16: SUBSTRING con LIKE

**Enunciado:**
Escribe una consulta que muestre los últimos 3 caracteres del nombre de cada cliente.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT customerName, SUBSTRING(customerName, -3) AS "Últimos 3 Caracteres" FROM customers;
```

**Nota:** Algunos sistemas usan `SUBSTRING(texto FROM -3)` o `RIGHT(texto, 3)`. La sintaxis exacta depende del motor SQL.

**Explicación:**
`SUBSTRING()` con un número negativo cuenta desde el final del texto. "Blue Whale Records" devolvería "rds" (los últimos 3 caracteres).

</details>

---

## Ejercicio 17: TRIM en búsqueda

**Enunciado:**
Escribe una consulta que cuente cuántos clientes hay en la tabla `customers`.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT COUNT(*) AS "Total Clientes" FROM customers;
```

**Explicación:**
Este es un ejercicio base para comparar. `COUNT(*)` sin usar funciones escalares. Este será nuestro punto de referencia para otros ejercicios más complejos.

</details>

---

## Ejercicio 18: LOWER para normalizar búsquedas

**Enunciado:**
Escribe una consulta que muestre el país en minúsculas para todos los clientes que están en "USA".

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT LOWER(country) AS "País Minúsculas" FROM customers WHERE country = 'USA';
```

**Explicación:**
Combinar `LOWER()` con `WHERE` es útil para transformar datos mientras se filtran. En este caso, convierte "USA" a "usa" en los resultados.

</details>

---

## Resumen de funciones escalares

| Función | Descripción | Ejemplo |
|---------|-------------|---------|
| **ROUND(valor, decimales)** | Redondea a decimales especificados | `ROUND(15.678, 2)` → 15.68 |
| **CEIL(valor)** | Redondea hacia arriba | `CEIL(15.1)` → 16 |
| **FLOOR(valor)** | Redondea hacia abajo | `FLOOR(15.9)` → 15 |
| **ABS(valor)** | Valor absoluto | `ABS(-10)` → 10 |
| **MOD(dividendo, divisor)** | Residuo de división | `MOD(47, 10)` → 7 |
| **UPPER(texto)** | Convierte a mayúsculas | `UPPER('Blue')` → 'BLUE' |
| **LOWER(texto)** | Convierte a minúsculas | `LOWER('Blue')` → 'blue' |
| **TRIM(texto)** | Elimina espacios iniciales/finales | `TRIM('  Blue  ')` → 'Blue' |
| **SUBSTRING(texto, inicio, longitud)** | Extrae parte del texto | `SUBSTRING('Blue', 1, 3)` → 'Blu' |
| **COALESCE(valor1, valor2, ...)** | Devuelve primer no nulo | `COALESCE(null, 'B', 'C')` → 'B' |

---

## Diferencias clave

### ROUND vs CEIL vs FLOOR

- **ROUND(15.6)** → 16 (redondea al más cercano)
- **CEIL(15.1)** → 16 (siempre hacia arriba)
- **FLOOR(15.9)** → 15 (siempre hacia abajo)

### COUNT(*) vs COUNT(columna)

- **COUNT(*)** cuenta todas las filas
- **COUNT(columna)** cuenta solo valores no nulos

### UPPER vs LOWER

- **UPPER()** → TODO EN MAYÚSCULAS
- **LOWER()** → todo en minúsculas

---

## ¿Necesitas más ayuda?

Si tienes dudas sobre algún ejercicio o necesitas más práctica, recuerda:

- Las **funciones escalares** operan sobre cada fila individual
- Las **funciones de agregado** operan sobre múltiples filas y devuelven un valor
- Las funciones escalares pueden **anidarse** (una dentro de otra)
- Las funciones escalares pueden combinarse con **WHERE**, **ORDER BY** y **LIMIT**
- `COALESCE()` es muy útil para manejar **valores nulos**
- `TRIM()` es útil para limpiar datos con **espacios accidentales**
