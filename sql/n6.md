# Ejercicios SQL - CASE, GROUP BY, HAVING, JOINs y Subconsultas

Este conjunto de ejercicios está diseñado para practicar condicionales, agrupaciones, uniones y subconsultas. Todos los ejercicios usan conceptos básicos sin complejidad excesiva.

---

## Estructura de las tablas principales

- **customers**: customerNumber, customerName, city, country, creditLimit
- **orders**: orderNumber, orderDate, customerNumber, status
- **orderdetails**: orderNumber, productCode, quantityOrdered, priceEach
- **products**: productCode, productName, quantityInStock, buyPrice, MSRP
- **payments**: customerNumber, checkNumber, paymentDate, amount
- **employees**: employeeNumber, lastName, firstName, jobTitle, officeCode

---

## CONDICIONALES CON CASE

### Ejercicio 1: CASE simple - Clasificar orden por estado

**Enunciado:**
Escribe una consulta que muestre el número de orden (`orderNumber`), la fecha (`orderDate`), el estado (`status`), y una columna que clasifique el estado como:
- "Completada" si el estado es "Shipped"
- "En espera" si es "In Process"
- "Cancelada" si es "Cancelled"
- "Otro" para cualquier otro estado

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  orderNumber,
  orderDate,
  status,
  CASE 
    WHEN status = 'Shipped' THEN 'Completada'
    WHEN status = 'In Process' THEN 'En espera'
    WHEN status = 'Cancelled' THEN 'Cancelada'
    ELSE 'Otro'
  END AS "Clasificación"
FROM orders;
```

**Explicación:**
`CASE` evalúa condiciones en orden y devuelve el valor correspondiente de la primera condición que sea verdadera. Es como un "si-entonces-sino" en programación. El `ELSE` es opcional y se ejecuta si ninguna condición se cumple.

</details>

---

### Ejercicio 2: CASE con rangos numéricos

**Enunciado:**
Escribe una consulta que muestre el nombre del producto (`productName`), la cantidad en stock (`quantityInStock`), y una clasificación del nivel de stock:
- "Bajo" si quantityInStock < 1000
- "Medio" si es entre 1000 y 5000
- "Alto" si es > 5000

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  productName,
  quantityInStock,
  CASE 
    WHEN quantityInStock < 1000 THEN 'Bajo'
    WHEN quantityInStock >= 1000 AND quantityInStock <= 5000 THEN 'Medio'
    WHEN quantityInStock > 5000 THEN 'Alto'
  END AS "Nivel Stock"
FROM products;
```

**Explicación:**
Las condiciones `WHEN` se evalúan en orden. Si `quantityInStock` es 3500, la segunda condición será verdadera, así que devolverá "Medio". Una vez encuentra una condición verdadera, no evalúa las demás.

</details>

---

### Ejercicio 3: CASE con funciones

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente (`customerName`), el límite de crédito (`creditLimit`), y una categoría:
- "Premium" si creditLimit >= 100000
- "Estándar" si creditLimit >= 50000
- "Básico" si creditLimit < 50000

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerName,
  creditLimit,
  CASE 
    WHEN creditLimit >= 100000 THEN 'Premium'
    WHEN creditLimit >= 50000 THEN 'Estándar'
    ELSE 'Básico'
  END AS "Categoría Cliente"
FROM customers;
```

**Explicación:**
En este ejercicio usamos rangos para clasificar clientes. El `ELSE` final captura cualquier cliente con crédito menor a 50000 sin necesidad de una condición explícita.

</details>

---

## AGRUPACIONES DE DATOS

### Ejercicio 4: GROUP BY básico - Contar órdenes por cliente

**Enunciado:**
Escribe una consulta que muestre el número de cliente (`customerNumber`) y cuántas órdenes ha realizado. Agrupa por número de cliente.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  COUNT(*) AS "Total Órdenes"
FROM orders
GROUP BY customerNumber;
```

**Explicación:**
`GROUP BY` agrupa filas con el mismo `customerNumber`. `COUNT(*)` cuenta cuántas órdenes hay en cada grupo. Así obtenemos el número total de órdenes por cliente.

</details>

---

### Ejercicio 5: GROUP BY con SUM

**Enunciado:**
Escribe una consulta que muestre el número de cliente y el monto total de pagos que ha realizado. Agrupa por número de cliente.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  SUM(amount) AS "Total Pagos"
FROM payments
GROUP BY customerNumber;
```

**Explicación:**
Para cada grupo de cliente, sumamos todos sus pagos. El resultado es un resumen de cuánto dinero ha pagado cada cliente en total.

</details>

---

### Ejercicio 6: GROUP BY múltiple - Órdenes por cliente y estado

**Enunciado:**
Escribe una consulta que muestre el número de cliente (`customerNumber`), el estado de la orden (`status`), y cuántas órdenes hay en cada combinación cliente-estado.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  status,
  COUNT(*) AS "Total Órdenes"
FROM orders
GROUP BY customerNumber, status;
```

**Explicación:**
Cuando usas `GROUP BY` con múltiples columnas, SQL agrupa por cada combinación única de esos valores. Un cliente puede tener órdenes en estado "Shipped" y también en "In Process", y verás ambas filas separadas.

</details>

---

## HAVING - Filtrar después de agrupar

### Ejercicio 7: HAVING para filtrar grupos

**Enunciado:**
Escribe una consulta que muestre el número de cliente y el total de órdenes, pero solo para clientes que han realizado más de 5 órdenes.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  COUNT(*) AS "Total Órdenes"
FROM orders
GROUP BY customerNumber
HAVING COUNT(*) > 5;
```

**Explicación:**
`WHERE` filtra filas individuales ANTES de agrupar. `HAVING` filtra grupos DESPUÉS de agrupar. En este caso, primero agrupamos por cliente, luego filtramos solo los grupos que tienen más de 5 órdenes.

</details>

---

### Ejercicio 8: HAVING con SUM

**Enunciado:**
Escribe una consulta que muestre el número de cliente y el total de pagos, pero solo para clientes cuyo total de pagos sea mayor a 100000.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  SUM(amount) AS "Total Pagos"
FROM payments
GROUP BY customerNumber
HAVING SUM(amount) > 100000;
```

**Explicación:**
Primero sumamos todos los pagos de cada cliente, luego filtramos solo aquellos cuyo total supera 100000. Sin `HAVING`, veríamos todos los clientes; con `HAVING`, solo vemos los "clientes importantes".

</details>

---

### Ejercicio 9: WHERE y HAVING juntos

**Enunciado:**
Escribe una consulta que cuente las órdenes de estado "Shipped" agrupadas por cliente, pero solo mostrando clientes que tengan 3 o más órdenes "Shipped".

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  COUNT(*) AS "Órdenes Shipped"
FROM orders
WHERE status = 'Shipped'
GROUP BY customerNumber
HAVING COUNT(*) >= 3;
```

**Explicación:**
`WHERE` filtra solo órdenes con estado "Shipped" ANTES de agrupar. Luego agrupamos por cliente, y `HAVING` filtra solo clientes con 3 o más órdenes. El orden es: WHERE → GROUP BY → HAVING.

</details>

---

## INNER JOIN - Unir dos tablas

### Ejercicio 10: INNER JOIN básico - Órdenes con clientes

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente (`customerName`) y la fecha de la orden (`orderDate`). Únete la tabla `orders` con `customers` por `customerNumber`.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  c.customerName,
  o.orderDate
FROM orders o
INNER JOIN customers c ON o.customerNumber = c.customerNumber;
```

**Explicación:**
`INNER JOIN` combina filas de dos tablas donde hay una coincidencia en la condición `ON`. Aquí, buscamos órdenes cuyo `customerNumber` coincida con un cliente. Usamos alias (`o` para orders, `c` para customers) para acortar los nombres.

</details>

---

### Ejercicio 11: INNER JOIN con múltiples columnas

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente, el número de orden, y el nombre del producto. Únete `orders`, `customers` y `orderdetails` con `products`.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  c.customerName,
  o.orderNumber,
  p.productName
FROM orders o
INNER JOIN customers c ON o.customerNumber = c.customerNumber
INNER JOIN orderdetails od ON o.orderNumber = od.orderNumber
INNER JOIN products p ON od.productCode = p.productCode;
```

**Explicación:**
Puedes usar múltiples `INNER JOIN` para combinar más de dos tablas. Cada `JOIN` conecta una tabla con la anterior. La consulta sigue la ruta: orders → customers (por customerNumber) → orderdetails (por orderNumber) → products (por productCode).

</details>

---

### Ejercicio 12: INNER JOIN con agregado

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente y el total de dinero que ha gastado en todas sus órdenes.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  c.customerName,
  SUM(od.quantityOrdered * od.priceEach) AS "Total Gastado"
FROM customers c
INNER JOIN orders o ON c.customerNumber = o.customerNumber
INNER JOIN orderdetails od ON o.orderNumber = od.orderNumber
GROUP BY c.customerNumber, c.customerName;
```

**Explicación:**
Combinamos `INNER JOIN` con `GROUP BY` y una función de agregado. `quantityOrdered * priceEach` calcula el valor de cada línea de orden. Agrupamos por cliente para obtener el total por cliente.

</details>

---

## LEFT JOIN - Mantener todos los registros de la tabla izquierda

### Ejercicio 13: LEFT JOIN básico - Clientes y sus órdenes

**Enunciado:**
Escribe una consulta que muestre el nombre de cliente y el número de orden. Si un cliente no tiene órdenes, aún debe aparecer (mostrando NULL en orderNumber).

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  c.customerName,
  o.orderNumber
FROM customers c
LEFT JOIN orders o ON c.customerNumber = o.customerNumber;
```

**Explicación:**
`LEFT JOIN` mantiene TODAS las filas de la tabla de la izquierda (`customers`) y añade datos coincidentes de la derecha (`orders`). Si un cliente no tiene órdenes, verás su nombre con NULL en `orderNumber`. Es útil para encontrar clientes sin órdenes.

</details>

---

### Ejercicio 14: LEFT JOIN con COUNT

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente y cuántas órdenes ha realizado. Si no tiene órdenes, mostrar 0.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  c.customerName,
  COUNT(o.orderNumber) AS "Total Órdenes"
FROM customers c
LEFT JOIN orders o ON c.customerNumber = o.customerNumber
GROUP BY c.customerNumber, c.customerName;
```

**Explicación:**
`COUNT(o.orderNumber)` cuenta solo los `orderNumber` no nulos. Para clientes sin órdenes, `o.orderNumber` es NULL y la cuenta es 0. Combinamos `LEFT JOIN` con `GROUP BY` para agrupar por cliente.

</details>

---

## Ejercicio 15: CASE con JOIN

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente, el estado de la orden, y una clasificación usando CASE:
- "Completada" si status = "Shipped"
- "En proceso" si status = "In Process"
- "Otros" para el resto

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  c.customerName,
  o.status,
  CASE 
    WHEN o.status = 'Shipped' THEN 'Completada'
    WHEN o.status = 'In Process' THEN 'En proceso'
    ELSE 'Otros'
  END AS "Clasificación"
FROM customers c
INNER JOIN orders o ON c.customerNumber = o.customerNumber;
```

**Explicación:**
Combinamos `INNER JOIN` con `CASE`. Mostramos información de cliente y orden, y añadimos una columna con una clasificación basada en el estado.

</details>

---

## SUBCONSULTAS

### Ejercicio 16: Subconsulta simple - Productos más caros que el promedio

**Enunciado:**
Escribe una consulta que muestre los productos cuyo precio (`MSRP`) sea mayor que el precio promedio de todos los productos.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  productName,
  MSRP
FROM products
WHERE MSRP > (SELECT AVG(MSRP) FROM products);
```

**Explicación:**
La subconsulta `(SELECT AVG(MSRP) FROM products)` se ejecuta primero y devuelve un número (el promedio). Luego, la consulta externa filtra productos cuyo MSRP es mayor a ese promedio. Las subconsultas van entre paréntesis.

</details>

---

### Ejercicio 17: Subconsulta con IN

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente para todos los clientes que han realizado al menos una orden. Usa una subconsulta con IN.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerName
FROM customers
WHERE customerNumber IN (SELECT DISTINCT customerNumber FROM orders);
```

**Explicación:**
La subconsulta devuelve una lista de números de cliente que tienen órdenes. La consulta externa filtra clientes cuyo número está en esa lista. `DISTINCT` evita duplicados en la subconsulta.

</details>

---

### Ejercicio 18: Subconsulta en FROM

**Enunciado:**
Escribe una consulta que muestre clientes y cuántas órdenes han realizado, usando una subconsulta que primero cuente órdenes por cliente.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  c.customerName,
  subquery.totalOrdenes
FROM customers c
LEFT JOIN (
  SELECT customerNumber, COUNT(*) AS totalOrdenes
  FROM orders
  GROUP BY customerNumber
) subquery ON c.customerNumber = subquery.customerNumber;
```

**Explicación:**
La subconsulta en `FROM` actúa como una tabla temporal. Primero agrupamos órdenes por cliente y contamos. Luego unimos ese resultado con clientes. Es útil para crear "tablas temporales" complejas.

</details>

---

### Ejercicio 19: Subconsulta con NOT IN

**Enunciado:**
Escribe una consulta que muestre los nombres de productos que nunca han sido ordenados (no existen en `orderdetails`).

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  productName
FROM products
WHERE productCode NOT IN (SELECT productCode FROM orderdetails);
```

**Explicación:**
`NOT IN` es lo opuesto a `IN`. La subconsulta devuelve todos los códigos de producto que aparecen en órdenes. Filtramos productos cuyo código NO está en esa lista, encontrando productos nunca ordenados.

</details>

---

### Ejercicio 20: GROUP BY con subconsulta

**Enunciado:**
Escribe una consulta que muestre clientes cuya suma de pagos sea mayor que el promedio de pagos de todos los clientes.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  SUM(amount) AS "Total Pagos"
FROM payments
GROUP BY customerNumber
HAVING SUM(amount) > (SELECT AVG(amount) FROM payments);
```

**Explicación:**
La subconsulta `(SELECT AVG(amount) FROM payments)` calcula el promedio de todos los pagos. `HAVING` filtra solo grupos (clientes) cuyo total de pagos supera ese promedio. Aquí la subconsulta va en `HAVING`, no en `WHERE`.

</details>

---

## Consejos para evitar errores comunes

### Error 1: CASE sin END
❌ **Incorrecto:**
```sql
SELECT CASE WHEN status = 'Shipped' THEN 'Completada' FROM orders;
```

✅ **Correcto:**
```sql
SELECT CASE WHEN status = 'Shipped' THEN 'Completada' END FROM orders;
```

### Error 2: GROUP BY sin función de agregado
❌ **Incorrecto:**
```sql
SELECT customerNumber, orderNumber FROM orders GROUP BY customerNumber;
```

✅ **Correcto:**
```sql
SELECT customerNumber, COUNT(*) FROM orders GROUP BY customerNumber;
```

### Error 3: Usar WHERE en lugar de HAVING
❌ **Incorrecto:**
```sql
SELECT customerNumber, COUNT(*) FROM orders GROUP BY customerNumber WHERE COUNT(*) > 5;
```

✅ **Correcto:**
```sql
SELECT customerNumber, COUNT(*) FROM orders GROUP BY customerNumber HAVING COUNT(*) > 5;
```

### Error 4: Olvidar ON en JOIN
❌ **Incorrecto:**
```sql
SELECT c.customerName, o.orderNumber FROM customers c INNER JOIN orders o;
```

✅ **Correcto:**
```sql
SELECT c.customerName, o.orderNumber FROM customers c INNER JOIN orders o ON c.customerNumber = o.customerNumber;
```

### Error 5: Subconsulta sin paréntesis
❌ **Incorrecto:**
```sql
SELECT * FROM products WHERE MSRP > SELECT AVG(MSRP) FROM products;
```

✅ **Correcto:**
```sql
SELECT * FROM products WHERE MSRP > (SELECT AVG(MSRP) FROM products);
```

---

## Resumen de conceptos

| Concepto | Descripción | Ejemplo |
|----------|-------------|---------|
| **CASE** | Condicional en SQL | `CASE WHEN ... THEN ... END` |
| **GROUP BY** | Agrupa filas idénticas | `GROUP BY customerNumber` |
| **HAVING** | Filtra después de GROUP BY | `HAVING COUNT(*) > 5` |
| **INNER JOIN** | Solo coincidencias | `INNER JOIN ... ON` |
| **LEFT JOIN** | Mantiene tabla izquierda | `LEFT JOIN ... ON` |
| **Subconsulta** | Consulta dentro de otra | `WHERE ... IN (SELECT ...)` |

---

## Diferencias clave

### WHERE vs HAVING

- **WHERE**: Filtra filas ANTES de agrupar
- **HAVING**: Filtra grupos DESPUÉS de agrupar

### INNER JOIN vs LEFT JOIN

- **INNER JOIN**: Solo filas que coinciden en ambas tablas
- **LEFT JOIN**: Todas las filas de la tabla izquierda + coincidencias de la derecha

### CASE vs IF

- SQL usa **CASE**, no IF
- CASE es más legible en grandes consultas

---

## ¿Necesitas más ayuda?

Si tienes dudas, recuerda:
- `CASE` siempre necesita `END`
- `GROUP BY` requiere funciones de agregado o columnas agrupadas
- `HAVING` filtra DESPUÉS de agrupar (usa funciones de agregado)
- `JOIN` necesita `ON` para especificar la condición
- Las subconsultas van entre paréntesis
- Las subconsultas se ejecutan PRIMERO, luego su resultado se usa en la consulta externa
