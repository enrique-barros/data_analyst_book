# Ejercicios SQL - CASE, GROUP BY, JOINs y Subconsultas

Este conjunto de ejercicios está separado por temas, con conceptos simples y directos.

---

## CONDICIONALES CON CASE

### Ejercicio 1: CASE simple - Clasificar pedido por estado

**Enunciado:**
Escribe una consulta que muestre el número de pedido (`orderNumber`), la fecha (`orderDate`), el estado (`status`), y una columna que clasifique el estado como:
- "Entregado" si el estado es "Shipped"
- "En preparación" si es "In Process"
- "Cancelado" si es "Cancelled"
- "Otro" para cualquier otro estado

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  orderNumber,
  orderDate,
  status,
  CASE 
    WHEN status = 'Shipped' THEN 'Entregado'
    WHEN status = 'In Process' THEN 'En preparación'
    WHEN status = 'Cancelled' THEN 'Cancelado'
    ELSE 'Otro'
  END AS "Clasificación"
FROM orders;
```

**Explicación:**
`CASE` evalúa condiciones en orden y devuelve el valor correspondiente de la primera condición que sea verdadera. El `ELSE` es opcional y se ejecuta si ninguna condición se cumple.

</details>

---

### Ejercicio 2: CASE con rangos numéricos

**Enunciado:**
Escribe una consulta que muestre el nombre del producto (`productName`), la cantidad en stock (`quantityInStock`), y una clasificación del nivel de almacén:
- "Bajo" si quantityInStock < 1000
- "Medio" si es entre 1000 y 5000
- "Alto" si es > 5000

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  productName,
  quantityInStock,
  CASE 
    WHEN quantityInStock < 1000 THEN 'Bajo'
    WHEN quantityInStock >= 1000 AND quantityInStock <= 5000 THEN 'Medio'
    WHEN quantityInStock > 5000 THEN 'Alto'
  END AS "Nivel Stock"
FROM products;
```

**Explicación:**
Las condiciones `WHEN` se evalúan en orden. Una vez encuentra una condición verdadera, no evalúa las demás.

</details>

---

### Ejercicio 3: CASE para categorizar clientes

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente (`customerName`), el límite de crédito (`creditLimit`), y una categoría:
- "Premium" si creditLimit >= 100000
- "Estándar" si creditLimit >= 50000
- "Básico" si creditLimit < 50000

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerName,
  creditLimit,
  CASE 
    WHEN creditLimit >= 100000 THEN 'Premium'
    WHEN creditLimit >= 50000 THEN 'Estándar'
    ELSE 'Básico'
  END AS "Categoría"
FROM customers;
```

**Explicación:**
El `ELSE` final captura cualquier cliente con crédito menor a 50000 sin necesidad de escribir una condición explícita.

</details>

---

## GROUP BY Y HAVING

### Ejercicio 4: GROUP BY básico - Contar pedidos por cliente

**Enunciado:**
Escribe una consulta que muestre el número de cliente (`customerNumber`) y cuántos pedidos ha realizado. Agrupa por número de cliente.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  COUNT(*) AS "Total Pedidos"
FROM orders
GROUP BY customerNumber;
```

**Explicación:**
`GROUP BY` agrupa filas con el mismo `customerNumber`. `COUNT(*)` cuenta cuántos pedidos hay en cada grupo.

</details>

---

### Ejercicio 5: GROUP BY con SUM - Total de pagos por cliente

**Enunciado:**
Escribe una consulta que muestre el número de cliente y el importe total de pagos que ha realizado.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  SUM(amount) AS "Total Pagos"
FROM payments
GROUP BY customerNumber;
```

**Explicación:**
Para cada grupo de cliente, sumamos todos sus pagos. El resultado es el dinero total que ha pagado cada cliente.

</details>

---

### Ejercicio 6: GROUP BY múltiple - Pedidos por cliente y estado

**Enunciado:**
Escribe una consulta que muestre el número de cliente, el estado del pedido (`status`), y cuántos pedidos hay en cada combinación.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  status,
  COUNT(*) AS "Total Pedidos"
FROM orders
GROUP BY customerNumber, status;
```

**Explicación:**
Cuando usas `GROUP BY` con múltiples columnas, SQL agrupa por cada combinación única de esos valores.

</details>

---

### Ejercicio 7: HAVING - Filtrar grupos con más de 5 pedidos

**Enunciado:**
Escribe una consulta que muestre el número de cliente y el total de pedidos, pero solo para clientes que han realizado más de 5 pedidos.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  COUNT(*) AS "Total Pedidos"
FROM orders
GROUP BY customerNumber
HAVING COUNT(*) > 5;
```

**Explicación:**
`WHERE` filtra filas individuales ANTES de agrupar. `HAVING` filtra grupos DESPUÉS de agrupar. Aquí primero agrupamos, luego filtramos solo grupos con más de 5 pedidos.

</details>

---

### Ejercicio 8: HAVING con SUM - Clientes con pagos > 100000

**Enunciado:**
Escribe una consulta que muestre el número de cliente y el total de pagos, pero solo para clientes cuyo total de pagos sea mayor a 100000.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  SUM(amount) AS "Total Pagos"
FROM payments
GROUP BY customerNumber
HAVING SUM(amount) > 100000;
```

**Explicación:**
Primero sumamos todos los pagos de cada cliente, luego `HAVING` filtra solo aquellos cuyo total supera 100000.

</details>

---

### Ejercicio 9: WHERE y HAVING juntos

**Enunciado:**
Escribe una consulta que cuente los pedidos de estado "Shipped" agrupados por cliente, pero solo mostrando clientes que tengan 3 o más pedidos "Shipped".

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  COUNT(*) AS "Pedidos Entregados"
FROM orders
WHERE status = 'Shipped'
GROUP BY customerNumber
HAVING COUNT(*) >= 3;
```

**Explicación:**
`WHERE` filtra solo pedidos con estado "Shipped" ANTES de agrupar. Luego agrupamos y `HAVING` filtra solo grupos con 3 o más. El orden es: WHERE → GROUP BY → HAVING.

</details>

---

## INNER JOIN

### Ejercicio 10: INNER JOIN básico - Nombre de cliente con fecha de pedido

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente (`customerName`) y la fecha del pedido (`orderDate`).

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customers.customerName,
  orders.orderDate
FROM orders
INNER JOIN customers ON orders.customerNumber = customers.customerNumber;
```

**Explicación:**
`INNER JOIN` combina filas de dos tablas donde hay coincidencia. Aquí buscamos pedidos cuyo `customerNumber` coincida con un cliente en la tabla `customers`. Usamos el nombre completo de la tabla seguido de un punto y el nombre de la columna.

</details>

---

### Ejercicio 11: INNER JOIN - Cliente, pedido y producto

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente, el número de pedido, y el nombre del producto.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customers.customerName,
  orders.orderNumber,
  products.productName
FROM orders
INNER JOIN customers ON orders.customerNumber = customers.customerNumber
INNER JOIN orderdetails ON orders.orderNumber = orderdetails.orderNumber
INNER JOIN products ON orderdetails.productCode = products.productCode;
```

**Explicación:**
Puedes usar múltiples `INNER JOIN` para combinar más de dos tablas. Cada `JOIN` conecta una tabla nueva. La consulta sigue la ruta: pedidos → clientes → detalles del pedido → productos.

</details>

---

### Ejercicio 12: INNER JOIN - Nombre de cliente con nombre de producto

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente y el nombre del producto (solo para productos que han sido pedidos).

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customers.customerName,
  products.productName
FROM orders
INNER JOIN customers ON orders.customerNumber = customers.customerNumber
INNER JOIN orderdetails ON orders.orderNumber = orderdetails.orderNumber
INNER JOIN products ON orderdetails.productCode = products.productCode;
```

**Explicación:**
Es la misma estructura que el ejercicio anterior, pero solo mostramos dos columnas: cliente y producto. Con `INNER JOIN`, solo vemos combinaciones que existen en todas las tablas.

</details>

---

## LEFT JOIN

### Ejercicio 13: LEFT JOIN básico - Clientes y sus pedidos

**Enunciado:**
Escribe una consulta que muestre el nombre de cliente y el número de pedido. Si un cliente no tiene pedidos, aún debe aparecer (mostrando NULL en orderNumber).

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customers.customerName,
  orders.orderNumber
FROM customers
LEFT JOIN orders ON customers.customerNumber = orders.customerNumber;
```

**Explicación:**
`LEFT JOIN` mantiene TODAS las filas de la tabla izquierda (`customers`) y añade datos coincidentes de la derecha (`orders`). Si un cliente no tiene pedidos, verás su nombre con NULL en `orderNumber`. Es útil para encontrar clientes sin pedidos.

</details>

---

### Ejercicio 14: LEFT JOIN con COUNT

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente y cuántos pedidos ha realizado. Si no tiene pedidos, mostrar 0.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customers.customerName,
  COUNT(orders.orderNumber) AS "Total Pedidos"
FROM customers
LEFT JOIN orders ON customers.customerNumber = orders.customerNumber
GROUP BY customers.customerNumber, customers.customerName;
```

**Explicación:**
`COUNT(orders.orderNumber)` cuenta solo los `orderNumber` no nulos. Para clientes sin pedidos, `orders.orderNumber` es NULL y la cuenta es 0. Combinamos `LEFT JOIN` con `GROUP BY` para agrupar por cliente.

</details>

---

### Ejercicio 15: LEFT JOIN - Clientes con su ciudad

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente, su ciudad, y cuántos pedidos ha realizado.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customers.customerName,
  customers.city,
  COUNT(orders.orderNumber) AS "Total Pedidos"
FROM customers
LEFT JOIN orders ON customers.customerNumber = orders.customerNumber
GROUP BY customers.customerNumber, customers.customerName, customers.city;
```

**Explicación:**
Mostramos más columnas de la tabla `customers` (ciudad) junto con el conteo de pedidos. El `LEFT JOIN` asegura que vemos todos los clientes, incluso los que no tienen pedidos.

</details>

---

## SUBCONSULTAS

### Ejercicio 16: Subconsulta simple - Productos más caros que el promedio

**Enunciado:**
Escribe una consulta que muestre los nombres de los productos cuyo precio (`MSRP`) sea mayor que el precio promedio de todos los productos.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  productName,
  MSRP
FROM products
WHERE MSRP > (SELECT AVG(MSRP) FROM products);
```

**Explicación:**
La subconsulta `(SELECT AVG(MSRP) FROM products)` se ejecuta primero y calcula el promedio de precios. Luego, la consulta externa filtra productos cuyo precio es mayor a ese promedio. Las subconsultas van entre paréntesis.

</details>

---

### Ejercicio 17: Subconsulta con IN - Clientes que han hecho pedidos

**Enunciado:**
Escribe una consulta que muestre el nombre del cliente para todos los clientes que han realizado al menos un pedido.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerName
FROM customers
WHERE customerNumber IN (SELECT customerNumber FROM orders);
```

**Explicación:**
La subconsulta devuelve una lista de números de cliente que tienen pedidos. La consulta externa filtra clientes cuyo número está en esa lista. Solo vemos clientes que han pedido algo.

</details>

---

### Ejercicio 18: Subconsulta con NOT IN - Productos nunca pedidos

**Enunciado:**
Escribe una consulta que muestre los nombres de productos que nunca han sido pedidos.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  productName
FROM products
WHERE productCode NOT IN (SELECT productCode FROM orderdetails);
```

**Explicación:**
`NOT IN` es lo opuesto a `IN`. La subconsulta devuelve todos los códigos de producto que aparecen en pedidos. Filtramos productos cuyo código NO está en esa lista, encontrando productos que nadie ha pedido nunca.

</details>

---

## Consejos para evitar errores comunes

### Error 1: CASE sin END
❌ **Incorrecto:**
```sql
SELECT CASE WHEN status = 'Shipped' THEN 'Entregado' FROM orders;
```

✅ **Correcto:**
```sql
SELECT CASE WHEN status = 'Shipped' THEN 'Entregado' END FROM orders;
```

### Error 2: GROUP BY sin función de agregado en columnas no agrupadas
❌ **Incorrecto:**
```sql
SELECT customerNumber, orderNumber FROM orders GROUP BY customerNumber;
```

✅ **Correcto:**
```sql
SELECT customerNumber, COUNT(*) FROM orders GROUP BY customerNumber;
```

### Error 3: Usar WHERE en lugar de HAVING
❌ **Incorrecto:**
```sql
SELECT customerNumber, COUNT(*) FROM orders GROUP BY customerNumber WHERE COUNT(*) > 5;
```

✅ **Correcto:**
```sql
SELECT customerNumber, COUNT(*) FROM orders GROUP BY customerNumber HAVING COUNT(*) > 5;
```

### Error 4: Olvidar ON en JOIN
❌ **Incorrecto:**
```sql
SELECT customers.customerName, orders.orderNumber FROM customers INNER JOIN orders;
```

✅ **Correcto:**
```sql
SELECT customers.customerName, orders.orderNumber FROM customers INNER JOIN orders ON customers.customerNumber = orders.customerNumber;
```

### Error 5: Subconsulta sin paréntesis
❌ **Incorrecto:**
```sql
SELECT * FROM products WHERE MSRP > SELECT AVG(MSRP) FROM products;
```

✅ **Correcto:**
```sql
SELECT * FROM products WHERE MSRP > (SELECT AVG(MSRP) FROM products);
```

---

## Resumen de conceptos

| Concepto | Descripción | Uso |
|----------|-------------|-----|
| **CASE** | Condicional if-then-else en SQL | Clasificar o etiquetar datos |
| **GROUP BY** | Agrupa filas idénticas | Agrupar por una o más columnas |
| **HAVING** | Filtra después de GROUP BY | Filtrar grupos, no filas individuales |
| **INNER JOIN** | Solo coincidencias entre tablas | Combinar datos que se relacionan |
| **LEFT JOIN** | Mantiene todas las filas de la tabla izquierda | Ver incluso registros sin coincidencia |
| **Subconsulta** | Consulta dentro de otra consulta | Crear condiciones dinámicas |

---

## Diferencias clave

### WHERE vs HAVING
- **WHERE**: Filtra filas ANTES de agrupar
- **HAVING**: Filtra grupos DESPUÉS de agrupar

### INNER JOIN vs LEFT JOIN
- **INNER JOIN**: Solo filas que coinciden en ambas tablas
- **LEFT JOIN**: Todas las filas de la tabla izquierda + coincidencias de la derecha

### IN vs NOT IN
- **IN**: Filtra valores que están en una lista
- **NOT IN**: Filtra valores que NO están en una lista

---

## ¿Necesitas más ayuda?

Si tienes dudas, recuerda:
- `CASE` siempre necesita `END`
- `GROUP BY` requiere funciones de agregado
- `HAVING` filtra DESPUÉS de agrupar
- `JOIN` necesita `ON` para especificar cómo conectar
- Las subconsultas van entre paréntesis
- Las subconsultas se ejecutan PRIMERO
