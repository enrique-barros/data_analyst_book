# Ejercicios SQL - CASE, GROUP BY, JOINs y Subconsultas

## CONDICIONALES CON CASE

### Ejercicio 1: CASE simple - Clasificar pedido por estado

**Enunciado:**
Necesitas crear una nueva columna que traduzca los estados de los pedidos a un formato más legible.

Muestra estas columnas:
- El número de pedido (`orderNumber`)
- La fecha del pedido (`orderDate`)
- El estado actual del pedido (`status`)
- Una columna nueva creada con CASE que traduzca el estado:
  - Si status = "Shipped" → mostrar "Entregado"
  - Si status = "In Process" → mostrar "En preparación"
  - Si status = "Cancelled" → mostrar "Cancelado"
  - Para cualquier otro estado → mostrar "Otro"

**Estructura que necesitas:**
- SELECT (incluye las 3 columnas normales + la columna con CASE)
- FROM orders
- CASE WHEN ... THEN ... WHEN ... THEN ... ELSE ... END

**Pista:** Usa CASE anidado dentro de SELECT para crear la columna de clasificación.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  orderNumber,
  orderDate,
  status,
  CASE 
    WHEN status = 'Shipped' THEN 'Entregado'
    WHEN status = 'In Process' THEN 'En preparación'
    WHEN status = 'Cancelled' THEN 'Cancelado'
    ELSE 'Otro'
  END AS "Clasificación"
FROM orders;
```

**Explicación:**
`CASE` evalúa condiciones en orden y devuelve el valor correspondiente de la primera condición que sea verdadera. El `ELSE` es opcional y se ejecuta si ninguna condición se cumple.

</details>

---

### Ejercicio 2: CASE con rangos numéricos

**Enunciado:**
El departamento de almacén quiere clasificar los productos según su nivel de stock actual para gestionar mejor el inventario. Necesitas crear una consulta que muestre:
- El nombre del producto (`productName`)
- La cantidad actual en stock (`quantityInStock`)
- Una clasificación del nivel de almacén basada en la cantidad:
  - "Bajo" si hay menos de 1000 unidades
  - "Medio" si hay entre 1000 y 5000 unidades (inclusive)
  - "Alto" si hay más de 5000 unidades

Esta información ayudará al almacén a saber qué productos necesitan reabastecimiento urgente y cuáles tienen niveles saludables de inventario.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  productName,
  quantityInStock,
  CASE 
    WHEN quantityInStock < 1000 THEN 'Bajo'
    WHEN quantityInStock >= 1000 AND quantityInStock <= 5000 THEN 'Medio'
    WHEN quantityInStock > 5000 THEN 'Alto'
  END AS "Nivel Stock"
FROM products;
```

**Explicación:**
Las condiciones `WHEN` se evalúan en orden. Una vez encuentra una condición verdadera, no evalúa las demás.

</details>

---

### Ejercicio 3: CASE para categorizar clientes

**Enunciado:**
El equipo de ventas necesita segmentar los clientes según su límite de crédito disponible para aplicar diferentes estrategias comerciales. Debes crear una consulta que muestre:
- El nombre del cliente (`customerName`)
- Su límite de crédito actual (`creditLimit`)
- Una categoría de cliente basada en su crédito:
  - "Premium" para clientes con límite de crédito de 100000 o superior
  - "Estándar" para clientes con crédito entre 50000 y 99999
  - "Básico" para clientes con crédito menor a 50000

Esta segmentación permitirá al equipo de ventas identificar rápidamente qué clientes son de mayor valor y cuáles pueden necesitar condiciones especiales.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerName,
  creditLimit,
  CASE 
    WHEN creditLimit >= 100000 THEN 'Premium'
    WHEN creditLimit >= 50000 THEN 'Estándar'
    ELSE 'Básico'
  END AS "Categoría"
FROM customers;
```

**Explicación:**
El `ELSE` final captura cualquier cliente con crédito menor a 50000 sin necesidad de escribir una condición explícita.

</details>

---

## GROUP BY Y HAVING

### Ejercicio 4: GROUP BY básico - Contar pedidos por cliente

**Enunciado:**
Necesitas resumir la información de la tabla `orders` agrupándola por cliente.

Muestra estas columnas:
- El número de cliente (`customerNumber`)
- El número total de pedidos que tiene ese cliente (usa COUNT(*))

**Estructura que necesitas:**
- SELECT customerNumber, COUNT(*) AS "Total Pedidos"
- FROM orders
- GROUP BY customerNumber

**Explicación:**
GROUP BY agrupa todas las filas que tienen el mismo customerNumber. COUNT(*) cuenta cuántas filas hay en cada grupo, es decir, cuántos pedidos tiene cada cliente.

**Pista:** Recuerda que cuando usas GROUP BY, en SELECT solo puedes poner la columna de agrupación y funciones de agregado como COUNT.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  COUNT(*) AS "Total Pedidos"
FROM orders
GROUP BY customerNumber;
```

**Explicación:**
`GROUP BY` agrupa filas con el mismo `customerNumber`. `COUNT(*)` cuenta cuántos pedidos hay en cada grupo.

</details>

---

### Ejercicio 5: GROUP BY con SUM - Total de pagos por cliente

**Enunciado:**
El departamento de contabilidad necesita conocer cuánto dinero ha pagado cada cliente en total para reconciliar sus cuentas. Debes crear una consulta que muestre:
- El número identificador del cliente (`customerNumber`)
- El importe total que ese cliente ha pagado (suma de todos sus pagos)

La consulta agrupará todos los pagos por cliente, permitiendo al departamento financiero ver de un vistazo cuánto ha invertido cada cliente en la empresa. Esta información es crucial para evaluar la rentabilidad de cada relación comercial.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  SUM(amount) AS "Total Pagos"
FROM payments
GROUP BY customerNumber;
```

**Explicación:**
Para cada grupo de cliente, sumamos todos sus pagos. El resultado es el dinero total que ha pagado cada cliente.

</details>

---

### Ejercicio 6: GROUP BY múltiple - Pedidos por cliente y estado

**Enunciado:**
La empresa quiere analizar más detalladamente la situación de los pedidos de cada cliente. Necesita saber no solo cuántos pedidos tiene cada cliente, sino también cómo están distribuidos según su estado actual. Debes crear una consulta que muestre:
- El número identificador del cliente (`customerNumber`)
- El estado actual del pedido (`status`)
- La cantidad de pedidos que ese cliente tiene en ese estado específico

Por ejemplo, el cliente 100 podría tener 3 pedidos "Shipped", 2 "In Process" y 1 "Cancelled". Esta información ayuda a entender mejor el ciclo de vida de los pedidos y detectar posibles problemas con ciertos clientes.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  status,
  COUNT(*) AS "Total Pedidos"
FROM orders
GROUP BY customerNumber, status;
```

**Explicación:**
Cuando usas `GROUP BY` con múltiples columnas, SQL agrupa por cada combinación única de esos valores.

</details>

---

### Ejercicio 7: HAVING - Filtrar grupos con más de 5 pedidos

**Enunciado:**
Similar al ejercicio anterior, pero ahora necesitas FILTRAR los grupos después de contar.

Muestra estas columnas:
- El número de cliente (`customerNumber`)
- El número total de pedidos que tiene ese cliente

Pero SOLO muestra los clientes que tienen MÁS de 5 pedidos. Ignora los clientes con 5 o menos pedidos.

**Estructura que necesitas:**
- SELECT customerNumber, COUNT(*) AS "Total Pedidos"
- FROM orders
- GROUP BY customerNumber
- HAVING COUNT(*) > 5

**Diferencia importante:**
- WHERE filtra ANTES de agrupar (filtra filas individuales)
- HAVING filtra DESPUÉS de agrupar (filtra grupos)

**Pista:** HAVING siempre va DESPUÉS de GROUP BY y contiene la condición que filtra los grupos.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  COUNT(*) AS "Total Pedidos"
FROM orders
GROUP BY customerNumber
HAVING COUNT(*) > 5;
```

**Explicación:**
`WHERE` filtra filas individuales ANTES de agrupar. `HAVING` filtra grupos DESPUÉS de agrupar. Aquí primero agrupamos, luego filtramos solo grupos con más de 5 pedidos.

</details>

---

### Ejercicio 8: HAVING con SUM - Clientes con pagos > 100000

**Enunciado:**
El departamento financiero necesita identificar a los clientes que son más rentables en términos de pagos acumulados. Debes crear una consulta que muestre:
- El número identificador del cliente (`customerNumber`)
- El importe total que ese cliente ha pagado en toda su historia como cliente

Con una condición importante: solo debes mostrar a los clientes cuyo total de pagos supera los 100000 euros. Estos son los clientes de alto valor económico que merecen atención especial. Esta información ayudará al departamento a identificar a los clientes premium que generan la mayor parte de los ingresos.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  SUM(amount) AS "Total Pagos"
FROM payments
GROUP BY customerNumber
HAVING SUM(amount) > 100000;
```

**Explicación:**
Primero sumamos todos los pagos de cada cliente, luego `HAVING` filtra solo aquellos cuyo total supera 100000.

</details>

---

### Ejercicio 9: WHERE y HAVING juntos

**Enunciado:**
El departamento de logística necesita analizar los pedidos que ya han sido entregados a los clientes. Quiere saber qué clientes tienen el historial más sólido de entregas completadas. Debes crear una consulta que muestre:
- El número identificador del cliente (`customerNumber`)
- El número de pedidos que ese cliente ha tenido con estado "Shipped" (entregados)

Pero con dos condiciones importantes:
1. Solo contar los pedidos que han sido entregados (estado = "Shipped"), ignorando los que aún están en proceso o cancelados
2. Solo mostrar a los clientes que tienen 3 o más pedidos entregados

Esta información ayuda a identificar a los clientes más satisfechos (porque sus pedidos se entregan) y que además son clientes frecuentes.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerNumber,
  COUNT(*) AS "Pedidos Entregados"
FROM orders
WHERE status = 'Shipped'
GROUP BY customerNumber
HAVING COUNT(*) >= 3;
```

**Explicación:**
`WHERE` filtra solo pedidos con estado "Shipped" ANTES de agrupar. Luego agrupamos y `HAVING` filtra solo grupos con 3 o más. El orden es: WHERE → GROUP BY → HAVING.

</details>

---

## INNER JOIN

### Ejercicio 10: INNER JOIN básico - Nombre de cliente con fecha de pedido

**Enunciado:**
Necesitas mostrar información que está en DOS TABLAS diferentes:
- En la tabla `customers` está el nombre del cliente (`customerName`)
- En la tabla `orders` está la fecha del pedido (`orderDate`)

Para combinar esta información, debes usar un **INNER JOIN** entre las dos tablas. Usa la columna `customerNumber` para unir ambas tablas (esta columna existe en ambas y es la que las relaciona).

Muestra:
- El nombre del cliente (`customerName`) de la tabla `customers`
- La fecha del pedido (`orderDate`) de la tabla `orders`

**Pista:** Necesitarás un solo INNER JOIN para conectar estas dos tablas.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customers.customerName,
  orders.orderDate
FROM orders
INNER JOIN customers ON orders.customerNumber = customers.customerNumber;
```

**Explicación:**
`INNER JOIN` combina filas de dos tablas donde hay coincidencia. Aquí buscamos pedidos cuyo `customerNumber` coincida con un cliente en la tabla `customers`. Usamos el nombre completo de la tabla seguido de un punto y el nombre de la columna.

</details>

---

### Ejercicio 11: INNER JOIN - Cliente, pedido y producto

**Enunciado:**
Esta vez necesitas información que está distribuida en CUATRO TABLAS diferentes. Debes mostrar:
- El nombre del cliente (`customerName`) de la tabla `customers`
- El número de pedido (`orderNumber`) de la tabla `orders`
- El nombre del producto (`productName`) de la tabla `products`

Para hacerlo, necesitas usar **TRES INNER JOINs diferentes**:
1. **Primer JOIN:** Conecta `orders` con `customers` usando `customerNumber`
2. **Segundo JOIN:** Conecta `orders` con `orderdetails` usando `orderNumber`
3. **Tercer JOIN:** Conecta `orderdetails` con `products` usando `productCode`

De esta forma, para cada producto en cada pedido, verás quién lo compró.

**Pista:** Estructura tu consulta así: SELECT → FROM orders → JOIN customers → JOIN orderdetails → JOIN products

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customers.customerName,
  orders.orderNumber,
  products.productName
FROM orders
INNER JOIN customers ON orders.customerNumber = customers.customerNumber
INNER JOIN orderdetails ON orders.orderNumber = orderdetails.orderNumber
INNER JOIN products ON orderdetails.productCode = products.productCode;
```

**Explicación:**
Puedes usar múltiples `INNER JOIN` para combinar más de dos tablas. Cada `JOIN` conecta una tabla nueva. La consulta sigue la ruta: pedidos → clientes → detalles del pedido → productos.

</details>

---

### Ejercicio 12: INNER JOIN - Nombre de cliente con nombre de producto

**Enunciado:**
Similar al ejercicio anterior, pero más simple. Necesitas información de CUATRO TABLAS, pero solo mostrarás DOS columnas:
- El nombre del cliente (`customerName`) de la tabla `customers`
- El nombre del producto (`productName`) de la tabla `products`

Para hacerlo, necesitas usar **TRES INNER JOINs** (igual que el ejercicio anterior):
1. **Primer JOIN:** Conecta `orders` con `customers` usando `customerNumber`
2. **Segundo JOIN:** Conecta `orders` con `orderdetails` usando `orderNumber`
3. **Tercer JOIN:** Conecta `orderdetails` con `products` usando `productCode`

La única diferencia con el ejercicio anterior es que NO muestras el `orderNumber`, solo cliente y producto.

**Pista:** La estructura del JOIN es idéntica al ejercicio 11, solo cambias lo que pones en el SELECT.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customers.customerName,
  products.productName
FROM orders
INNER JOIN customers ON orders.customerNumber = customers.customerNumber
INNER JOIN orderdetails ON orders.orderNumber = orderdetails.orderNumber
INNER JOIN products ON orderdetails.productCode = products.productCode;
```

**Explicación:**
Es la misma estructura que el ejercicio anterior, pero solo mostramos dos columnas: cliente y producto. Con `INNER JOIN`, solo vemos combinaciones que existen en todas las tablas.

</details>

---

## LEFT JOIN

### Ejercicio 13: LEFT JOIN básico - Clientes y sus pedidos

**Enunciado:**
Necesitas combinar información de DOS TABLAS:
- La tabla `customers` con todos los clientes
- La tabla `orders` con todos los pedidos

El objetivo es ver TODOS los clientes, incluso aquellos que no tienen ningún pedido.

Usa un **LEFT JOIN** para conectar estas tablas usando `customerNumber`.

Muestra:
- El nombre del cliente (`customerName`) de la tabla `customers`
- El número de pedido (`orderNumber`) de la tabla `orders`

**Importante:** Si un cliente no tiene pedidos, el `orderNumber` mostrará NULL. Esto es normal y esperado con LEFT JOIN.

**Pista:** Necesitarás un solo LEFT JOIN: FROM customers LEFT JOIN orders ON ...

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customers.customerName,
  orders.orderNumber
FROM customers
LEFT JOIN orders ON customers.customerNumber = orders.customerNumber;
```

**Explicación:**
`LEFT JOIN` mantiene TODAS las filas de la tabla izquierda (`customers`) y añade datos coincidentes de la derecha (`orders`). Si un cliente no tiene pedidos, verás su nombre con NULL en `orderNumber`. Es útil para encontrar clientes sin pedidos.

</details>

---

### Ejercicio 14: LEFT JOIN con COUNT

**Enunciado:**
Necesitas combinar información de DOS TABLAS:
- La tabla `customers` con todos los clientes
- La tabla `orders` con todos los pedidos

Usa un **LEFT JOIN** para conectar estas tablas usando `customerNumber`.

Luego agrupa los resultados por cliente y cuenta cuántos pedidos tiene cada uno.

Muestra:
- El nombre del cliente (`customerName`) de la tabla `customers`
- El conteo de pedidos (`COUNT(orders.orderNumber)`) - si no tiene pedidos, mostrará 0

**Importante:** Necesitarás:
1. LEFT JOIN entre customers y orders
2. GROUP BY para agrupar por cliente
3. COUNT para contar los pedidos de cada cliente

**Pista:** Estructura: FROM customers → LEFT JOIN orders → GROUP BY customers.customerNumber, customers.customerName

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customers.customerName,
  COUNT(orders.orderNumber) AS "Total Pedidos"
FROM customers
LEFT JOIN orders ON customers.customerNumber = orders.customerNumber
GROUP BY customers.customerNumber, customers.customerName;
```

**Explicación:**
`COUNT(orders.orderNumber)` cuenta solo los `orderNumber` no nulos. Para clientes sin pedidos, `orders.orderNumber` es NULL y la cuenta es 0. Combinamos `LEFT JOIN` con `GROUP BY` para agrupar por cliente.

</details>

---

### Ejercicio 15: LEFT JOIN - Clientes con su ciudad

**Enunciado:**
Necesitas combinar información de DOS TABLAS:
- La tabla `customers` con todos los clientes (incluyendo su ciudad)
- La tabla `orders` con todos los pedidos

Usa un **LEFT JOIN** para conectar estas tablas usando `customerNumber`.

Luego agrupa los resultados por cliente y cuenta cuántos pedidos tiene cada uno.

Muestra:
- El nombre del cliente (`customerName`) de la tabla `customers`
- La ciudad del cliente (`city`) de la tabla `customers`
- El conteo de pedidos - si no tiene pedidos, mostrará 0

**Importante:** Necesitarás:
1. LEFT JOIN entre customers y orders
2. GROUP BY para agrupar por cliente (incluye customerNumber, customerName y city)
3. COUNT para contar los pedidos

**Pista:** En el GROUP BY debes incluir: customers.customerNumber, customers.customerName, customers.city

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customers.customerName,
  customers.city,
  COUNT(orders.orderNumber) AS "Total Pedidos"
FROM customers
LEFT JOIN orders ON customers.customerNumber = orders.customerNumber
GROUP BY customers.customerNumber, customers.customerName, customers.city;
```

**Explicación:**
Mostramos más columnas de la tabla `customers` (ciudad) junto con el conteo de pedidos. El `LEFT JOIN` asegura que vemos todos los clientes, incluso los que no tienen pedidos.

</details>

---

## SUBCONSULTAS

### Ejercicio 16: Subconsulta simple - Productos más caros que el promedio

**Enunciado:**
Necesitas encontrar productos con precio superior al promedio. Para hacerlo, sigue estos pasos:

**Paso 1:** Crea una subconsulta que calcule el precio promedio de TODOS los productos:
- Usa `SELECT AVG(MSRP) FROM products`
- Esta subconsulta debe ir entre paréntesis

**Paso 2:** En la consulta principal, filtra productos donde el precio es MAYOR que ese promedio:
- Tabla: `products`
- Columnas a mostrar: `productName` y `MSRP`
- Condición WHERE: MSRP > (resultado de la subconsulta)

Muestra:
- El nombre del producto (`productName`)
- El precio del producto (`MSRP`)

**Pista:** La estructura será: SELECT ... FROM products WHERE MSRP > (SELECT AVG(MSRP) FROM products)

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  productName,
  MSRP
FROM products
WHERE MSRP > (SELECT AVG(MSRP) FROM products);
```

**Explicación:**
La subconsulta `(SELECT AVG(MSRP) FROM products)` se ejecuta primero y calcula el promedio de precios. Luego, la consulta externa filtra productos cuyo precio es mayor a ese promedio. Las subconsultas van entre paréntesis.

</details>

---

### Ejercicio 17: Subconsulta con IN - Clientes que han hecho pedidos

**Enunciado:**
Necesitas encontrar solo los clientes que han realizado al menos un pedido. Para hacerlo, sigue estos pasos:

**Paso 1:** Crea una subconsulta que obtenga una lista de TODOS los números de cliente que tienen pedidos:
- Usa `SELECT customerNumber FROM orders`
- Esta lista puede tener números repetidos, pero eso no importa

**Paso 2:** En la consulta principal, filtra solo los clientes cuyo número esté en esa lista:
- Tabla: `customers`
- Columnas a mostrar: `customerName`
- Condición WHERE: customerNumber IN (resultado de la subconsulta)

Muestra:
- El nombre del cliente (`customerName`)

**Pista:** La estructura será: SELECT customerName FROM customers WHERE customerNumber IN (SELECT customerNumber FROM orders)

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  customerName
FROM customers
WHERE customerNumber IN (SELECT customerNumber FROM orders);
```

**Explicación:**
La subconsulta devuelve una lista de números de cliente que tienen pedidos. La consulta externa filtra clientes cuyo número está en esa lista. Solo vemos clientes que han pedido algo.

</details>

---

### Ejercicio 18: Subconsulta con NOT IN - Productos nunca pedidos

**Enunciado:**
Necesitas encontrar productos que NUNCA han sido pedidos por ningún cliente. Para hacerlo, sigue estos pasos:

**Paso 1:** Crea una subconsulta que obtenga una lista de TODOS los códigos de producto que SÍ han sido pedidos:
- Usa `SELECT productCode FROM orderdetails`
- Esto te da todos los productos que aparecen en pedidos

**Paso 2:** En la consulta principal, filtra productos cuyo código NO esté en esa lista:
- Tabla: `products`
- Columnas a mostrar: `productName`
- Condición WHERE: productCode NOT IN (resultado de la subconsulta)

Muestra:
- El nombre del producto (`productName`)

**Pista:** La estructura será: SELECT productName FROM products WHERE productCode NOT IN (SELECT productCode FROM orderdetails)

**Nota:** NOT IN es lo opuesto a IN: mientras que IN encuentra elementos que SÍ están en la lista, NOT IN encuentra elementos que NO están en la lista.

<details>
<summary><b>Ver solución</b></summary>

**Solución:**
```sql
SELECT 
  productName
FROM products
WHERE productCode NOT IN (SELECT productCode FROM orderdetails);
```

**Explicación:**
`NOT IN` es lo opuesto a `IN`. La subconsulta devuelve todos los códigos de producto que aparecen en pedidos. Filtramos productos cuyo código NO está en esa lista, encontrando productos que nadie ha pedido nunca.

</details>

---

## Consejos para evitar errores comunes

### Error 1: CASE sin END
❌ **Incorrecto:**
```sql
SELECT CASE WHEN status = 'Shipped' THEN 'Entregado' FROM orders;
```

✅ **Correcto:**
```sql
SELECT CASE WHEN status = 'Shipped' THEN 'Entregado' END FROM orders;
```

### Error 2: GROUP BY sin función de agregado en columnas no agrupadas
❌ **Incorrecto:**
```sql
SELECT customerNumber, orderNumber FROM orders GROUP BY customerNumber;
```

✅ **Correcto:**
```sql
SELECT customerNumber, COUNT(*) FROM orders GROUP BY customerNumber;
```

### Error 3: Usar WHERE en lugar de HAVING
❌ **Incorrecto:**
```sql
SELECT customerNumber, COUNT(*) FROM orders GROUP BY customerNumber WHERE COUNT(*) > 5;
```

✅ **Correcto:**
```sql
SELECT customerNumber, COUNT(*) FROM orders GROUP BY customerNumber HAVING COUNT(*) > 5;
```

### Error 4: Olvidar ON en JOIN
❌ **Incorrecto:**
```sql
SELECT customers.customerName, orders.orderNumber FROM customers INNER JOIN orders;
```

✅ **Correcto:**
```sql
SELECT customers.customerName, orders.orderNumber FROM customers INNER JOIN orders ON customers.customerNumber = orders.customerNumber;
```

### Error 5: Subconsulta sin paréntesis
❌ **Incorrecto:**
```sql
SELECT * FROM products WHERE MSRP > SELECT AVG(MSRP) FROM products;
```

✅ **Correcto:**
```sql
SELECT * FROM products WHERE MSRP > (SELECT AVG(MSRP) FROM products);
```

---

## Resumen de conceptos

| Concepto | Descripción | Uso |
|----------|-------------|-----|
| **CASE** | Condicional if-then-else en SQL | Clasificar o etiquetar datos |
| **GROUP BY** | Agrupa filas idénticas | Agrupar por una o más columnas |
| **HAVING** | Filtra después de GROUP BY | Filtrar grupos, no filas individuales |
| **INNER JOIN** | Solo coincidencias entre tablas | Combinar datos que se relacionan |
| **LEFT JOIN** | Mantiene todas las filas de la tabla izquierda | Ver incluso registros sin coincidencia |
| **Subconsulta** | Consulta dentro de otra consulta | Crear condiciones dinámicas |

---

## Diferencias clave

### WHERE vs HAVING
- **WHERE**: Filtra filas ANTES de agrupar
- **HAVING**: Filtra grupos DESPUÉS de agrupar

### INNER JOIN vs LEFT JOIN
- **INNER JOIN**: Solo filas que coinciden en ambas tablas
- **LEFT JOIN**: Todas las filas de la tabla izquierda + coincidencias de la derecha

### IN vs NOT IN
- **IN**: Filtra valores que están en una lista
- **NOT IN**: Filtra valores que NO están en una lista

---

## ¿Necesitas más ayuda?

Si tienes dudas, recuerda:
- `CASE` siempre necesita `END`
- `GROUP BY` requiere funciones de agregado
- `HAVING` filtra DESPUÉS de agrupar
- `JOIN` necesita `ON` para especificar cómo conectar
- Las subconsultas van entre paréntesis
- Las subconsultas se ejecutan PRIMERO
